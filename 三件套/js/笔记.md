# js

## 基础

1. 闭包
2. 说说你对作用域链的理解
3. JavaScript原型，原型链有什么特点
4. 解释什么是事件代理
5. JavaScript如何实现继承
6. 谈谈this对象的理解
7. 事件模型
8. new操作符具体干了什么
9. Ajax原理
10. 如何解决跨域问题
11. 模块化开发怎么做
12. 异步加载js的方式有哪些（延迟加载）
13. 哪些操作会造成内存泄露
14. XML和JSON的区别
15. 谈谈你对webpack的看法
16. 说说你对AMD和commonjs的理解
17. 常见web安全及防护原理
18. 用过哪些设计模式
19. 为什么要有同源限制
20. offsetWidth/offsetHeight，clientWidth/clientHeight与scrollWidth/scrollHeight的区别
21. JavaScript有哪些方法定义对象
22. 常见兼容性问题
23. 说说你对promise的了解
24. 谈谈你对AMD、CMD的理解
25. web开发中会话跟踪的方法有哪些
26. js的数据类型
27. js的内置对象
28. eval是做什么的
29. null、undefined的区别
30. js的严格模式
31. 同步异步的区别
32. 渐进增强和优雅降级
33. defer和async
34. 说说严格模式的限制
35. attribute和property的区别
36. ES6的新特性
37. 如何通过js判断一个数组
38. let与var的区别
39. map与forEach的区别
40. 函数式编程
41. 箭头函数与普通函数的区别
42. 函数中this的指向
43. 异步编程的实现方式
44. js动画与css动画的区别
45. 事件的各个阶段
46. 打乱数组
47. JavaScript中callee和caller的作用
48. 数组去重方法总结
49. 怎么判断两个对象相等
50. 项目做过哪些性能优化
51. 浏览器的缓存
52. webSocket
53. 深浅拷贝
54. 防抖和节流
55. 变量提升
56. 什么是单线程，和异步的关系
57. 前端的hybrid
58. 前端的组件化
59. MVVM
60. 说说event loop
61. 事件流
62. 垃圾回收机制
63. 手动实现promise
64. 浏览器的缓存机制
65. Ajax、axios、fetch的区别
66. 描述浏览器的渲染过程，DOM树和渲染树的区别
67. script的位置是否会影响首屏加载的时间
68. DOM0、DOM2、DOM3事件处理方式区别
69. 事件的冒泡与捕获
70. 函数的bind、call、apply手动实现
71. web应用从服务器主动推送Data到客户端有哪些方式
72. 属性的遍历
73. arguments对象



## 进阶

1. 类型及检测方式
2. this
3. apply/call/bind原理
4. 变量提升
5. 执行上下文
6. 作用域
7. 闭包
8. new的原理
9. 原型/原型链
10. 继承
11. 面向对象
12. 事件机制
13. 模块化
14. iterator
15. Promise
16. Generator
17. async/await
18. 事件循环
19. 垃圾回收
20. 内存泄露
21. 深浅拷贝
22. 节流与防抖
23. Proxy代理
24. Ajax
25. 深入数组



## 高频

1. typeof类型判断
2. 类型转换
3. this
4. == 和 === 有什么区别
5. 闭包
6. 深浅拷贝
7. 原型
8. var、let、const区别
9. 原型继承和class继承
10. 模块化
11. 实现一个简洁版的Promise
12. Event Loop
    1. 进程与线程
    2. 执行栈
    3. 浏览器中的Event Loop
    4. Node中的Event Loop
13. 手写call、apply、bind
14. new
15. instanceof的原理
16. 为什么0.1+0.2 !== 0.3
17. 事件机制
    1. 事件触发三阶段
    2. 注册事件
    3. 事件代理
18. 跨域
    1. JSONP
    2. CORS
    3. document.domain
    4. postMessage
19. 存储
20. 浏览器缓存机制
    1. 缓存位置
    2. 缓存策略
       1. 强缓存
       2. 协商缓存
       3. 实际场景应用缓存策略
21. 浏览器渲染原理
    1. 渲染过程
    2. 为什么操作DOM慢
    3. 什么情况阻塞渲染
    4. 重绘和回流
    5. 减少重绘和回流
22. 安全防范
    1. XSS
    2. CSRF
    3. 点击劫持
23. 从V8中看JS性能优化
    1. 测试性能工具
    2. JS性能优化
24. 性能优化
    1. 图片优化
    2. 图片加载优化
    3. DNS预解析
    4. 节流
    5. 防抖
    6. 预加载
    7. 预渲染
    8. 懒执行
    9. 懒加载
    10. CDN
25. webpack性能优化
    1. 减少webpack打包时间
    2. 减少webpack打包后的文件体积
26. 实现小型打包工具
27. MVVM/虚拟DOM/前端路由
    1. MVVM
    2. Virtual DOM
    3. 路由原理
    4. Vue和React之间的区别
28. Vue常考知识点
    1. 生命周期钩子函数
    2. 组件通信
    3. extend能做什么
    4. mixin和mixins区别
    5. computed和watch区别
    6. keep-alive组件有什么作用
    7. v-show与v-if区别
    8. 组件中data什么时候可以使用对象
    9. 响应式原理
       1. Object.defineProperty的缺陷
       2. 编译过程
       3. NextTick原理分析
29. React常考知识点
    1. 生命周期
    2. setState
    3. 性能优化
    4. 通信
    5. HOC是什么，相比mixins有什么优点
    6. 事件机制
30. 监控
    1. 页面埋点
    2. 性能监控
    3. 异常监控
31. TCP/UDP
    1. UDP
    2. TCP
32. HTTP/TLS
    1. HTTP请求中的内容
    2. TLS
33. HTTP/2.0
    1. HTTP/2
    2. 二进制传输
    3. 多路复用
    4. Header压缩
    5. 服务端Push
    6. HTTP/3
34. 设计模式
    1. 工厂模式
    2. 单例模式
    3. 适配器模式
    4. 装饰模式
    5. 代理模式
    6. 发布订阅模式
    7. 外观模式
35. 常见数据结构
    1. 时间复杂度
    2. 栈
    3. 应用
    4. 队列
    5. 链表
    6. 树
    7. AVL树
    8. Trie
    9. 并查集
    10. 堆
36. 常考算法题
    1. 位运算
    2. 排序
    3. 冒泡排序
    4. 插入排序
    5. 选择排序
    6. 归并排序
    7. 快排
    8. 堆排序
    9. 链表
    10. 树
    11. 动态规划





## js

js语言特性：

- 解释型语言
  - 优点：跨平台，部署简单
  - 缺点：执行速度稍慢
- 弱类型语言
  - 弱类型：存放的数据类型可变。优点：灵活、易上手。缺点：不严谨
  - 强类型：存放的数据类型不可变。优点：严谨。缺点：不灵活、不易上手
- 单线程
  - 同步现象：上一件事情没有做完，下一件事情必须等待
- 异步
  - 提高单线程的执行效率

### JS语法基础

- 数据和数据类型

> 数据类型：数据的分类
>
> JS中的数据类型：
>
> 1. number（数字类型）
>    1. 数字类型加前缀，来表示不同的进制
>    2. 0：表示8进制
>    3. 0x：表示16进制
>    4. 0b：表示2进制
> 2. string（字符串类型）
>    1. 使用引号包起来的叫做字符串类型（```""、''```、还有反引号）
>    2. 在字符串中表示特殊字符，可以使用转义符`\`
> 3. Boolean（布尔类型）
>    1. `0 "" false undefined null NaN` 表示假，除了这6个全部为真
> 4. undefined（undefined类型）
>    1. 表示未定义，不存在
> 5. null（null类型）
>    1. 表示空，不存在
> 6. object（引用类型）
> 7. function（引用类型）
>    1. typeof一个函数得到的是`function`
>
> 如何判断一个数据的类型：
>
> 1. 在数据前面加上：`typeof`
> 2. `typeof(null)` ，得到的是`undefined`



- 变量

> 变量：变量是一块内存空间，用于保存数据
>
> 如何使用变量：
>
> 1. 声明（定义）变量：`var 变量名`
>    1. **变量声明后，它的值为undefined**
> 2. 给变量赋值（向变量的内存空间中存放数据）
>
> - 变量的值是可变的
>   - 变量可以被重新赋值，新的值会覆盖原来的值
> - 变量的名称（标识符）
>   - 只能以英文字母、下划线、$开头
>   - 其它位置可以出现数字、英文字母、下划线、$
>   - 不要使用关键字和保留字
> - 声明和赋值合并
> - 多个变量可以合并声明并赋值
>   - **任何可以书写数据的地方，都可以书写变量**
> - 若使用一个未声明的变量会导致错误（typeof除外，typeof一个未声明的变量时，得到undefined）
>   - **JS中存在变量提升**
>   - 所有变量的声明，会自动的提到代码的最顶部，但是这种提升不会超越脚本块
> - JS中允许定义多个同名变量
>   - 同名变量提升后会变成一个



- 变量和对象

> 原始类型：`number、string、boolean、undefined、null`
>
> 引用类型：`object、function`
>
> 在变量中存放对象：
>
> 1. 通过变量读取对象中的某个属性：`变量名.属性名`
>    1. **当读取的属性不存在时，会得到undefined**
>    2. **当读取属性的对象不存在（undefined 或 null），程序报错**
> 2. 通过变量，更改对象中的某个属性
>    1. **当赋值的执行不存在时，会添加属性**
> 3. 删除属性（`delete 变量名.属性名`）
> 4. 特殊的属性读取方式（属性表达式）`对象变量["属性名"]`
>
> - 某些属性中包含特殊字符
> - **属性的名字只能是字符串，如果你书写的是数字，会自动转换为字符串**
>
> 全局对象：
>
> 在浏览器环境中，全局对象为window，表示整个窗口。全局对象中的属性可以直接使用，不需要写全局对象名
>
> **开发者定义的所有变量，实际上会成为window对象的属性**
>
> **如果变量没有被赋值，则该变量不会覆盖window对象上的同名属性**



- 引用类型

> **原始类型的变量，存放的是具体的值**
>
> **引用类型的变量，存放的是内存地址**
>
> **凡是出现对象字面量的位置，都一定在内存出现一个新的对象**
>
> > JS的垃圾回收：
> >
> > JS引擎，会定期的发现内存中无法访问到的对象，该对象称之为垃圾，JS引擎会在合适的时间将其占用的内存释放。





### 运算符

- 运算符概述

> 操作符和操作数：
>
> - 操作符：运算符，参与运算的符号
> - 操作数：参与运算的数据，也称之为"元"
> - 目前接触的操作符：
>   - `=`：赋值符号：将右边的数据赋值给左边
>   - `.`：访问符号：用于访问对象的属性
>   - `[]`：访问符号：用于访问对象的属性
>   - `()`：函数调用
>
> 分类：
>
> - 按操作符数量区分
>   - 一元（目）运算符：`() . []`
>   - 二元（目）运算符：`+ - * / % =`
>   - 三元（目）运算符：`? :`
> - 功能区分
>   - 算数运算符
>   - 比较运算符
>   - 逻辑运算符
>   - 位运算符
>   - 其它
>
> 表达式：
>
> 表达式 = 操作符 + 操作数
>
> 每个表达式的运算结果叫做**返回值**，返回值的类型叫做**返回类型**
>
> 所有的表达式都可以当作数据使用
>
> 1. `=`：该表达式，返回赋值的结果
>2. `.`：属性访问表达式，返回的是属性的值
> 3. `[]`：属性访问表达式，返回的是属性的值
>4. `()`：函数调用表达式，返回的结果取决于函数的运行
> 5. 如果是一个声明+赋值的表达式。返回结果为`undefined`。
>6. `console.log` 函数调用的返回结果位`undefined`
> 7. 当在浏览器的控制台书写代码时，除了运行代码，还会输出表达式的返回结果



- 算数运算符

> 数学运算符：
>
> 1. `+ - * /`
> 2. `+ -`（正、负）
> 3. `%`
> 4. `++ --`
> 5. `**`（幂）
>
> 细节：
>
> 1. 数字运算是不精确的
> 2. 除数为0
>    1. 如果被除数是正数，得到结果Infinity（正无穷）
>    2. 如果被除数是负数，得到结果-Infinity（负无穷）
>    3. 如果被除数是0，得到结果NaN（not a number）
>
> > typeof函数的返回类型为string
> >
> > isNaN函数，该函数用于判断一个数据是否为NaN，返回Boolean
> >
> > isFinite函数，该函数用于判断一个数据是否是有限的，返回Boolean
>
> 3. 求余：余数的符号与被除数相同
>
> 其它类型使用算数运算：
>
> 1. 除加号之外的算数运算符
>
> **将原始类型转换为数字类型（自动完成转换），然后进行运算**
>
> - boolean：`true -> 1，false -> 0`
> - string：如果字符串内部是一个正确的数字，直接变成数字，如果是一个非数字，则得到NaN（能识别Infinity，不能把字符串内部的东西当作表达式），如果字符串是一个空字符串（没有任何内容），转换为0，字符串转换时，会忽略前后空格，不会忽略中间的空格
> - NaN虽然是数字，但它和任何数字做任何运算，得到的结果都是NaN
> - 两个特殊记忆：`null -> 0，undefined -> NaN`
> - 将对象类型先转换为字符串类型，然后再将字符串转换为数字类型
>   - `对象类型 -> "[object Object]" -> NaN`
>
> 2. 加号运算符
>
> - 加号一边有字符串，含义变为字符串拼接
>   - 将另一边的其它类型转换为字符串
>   - 数字：数字字符串
>   - `boolean：boolean字符串`
>   - `null：null字符串`
>   - `undefined："undefined"`
>   - `对象："[object Object]"`
> - 加号两边都没有字符串，但一边有对象，将对象转换为字符串，然后按照上面的规则进行
> - 其它情况和上面的数学运算一致



- 自增和自减

> 基本功能：
>
> `++`：将某个变量的值自增1
>
> `--`：将某个变量的值自减1
>
> 细节：
>
> - 自增自减表达式
>
> 1. `x++`：将变量x自增1，得到的表达式的值是自增之前的值
> 2. `++x`：将变量x自增1，得到的表达式的值是自增之后的值
> 3. `x--`：将变量x自减1，得到的表达式的值是自减之前的值
> 4. `--x`：将变量x自减1，得到的表达式的值是自减之后的值
>
> - 优先级：从高到低依次是
>
> 1. `++ --`
> 2. `* / %`
> 3. `+ -`
>
> 优先级的运算细节：
>
> 1. 从左到右依次查看
> 2. 如果遇到操作数，将数据的值直接取出
> 3. 如果遇到相邻的两个运算符，并且左边的运算符优先级大于等于右边的运算符，则直接运行左边的运算符



- 比较运算符

> 大小比较：`> < >= <=`
>
> 相等比较：`== != === !==`
>
> **比较运算符的返回类型：boolean**
>
> **算数运算符的优先级高于比较运算符**
>
> 大小比较：
>
> - 两个字符串比较大小，比较的是字符串的字符编码。
>
> **细节：**
>
> 1. **两个字符串比较大小，比较的是字符串的字符编码**
> 2. **如果一个不是字符串，并且两个都是原始类型，将它们都转换为数字进行比较**
>
> - NaN与任何数字比较，得到的都是false
> - Infinity比任何数字都大
> - -Infinity比任何数字都小
>
> 3. **如果其中一个是对象，将对象转换为原始类型后，按照规则1或2进行比较**
>
> 相等比较：
>
> - `==`：比较两个数据是否相等
> - `!=`：比较两个数据是否不相等
>
> **细节：**
>
> 1. 两端的类型相同，直接比较两个数据本身是否相同（两个对象比较的是地址）
> 2. 两端的类型不同
>    1. null 和 undefined，它们之间相等，和其它原始类型比较，则不相等
>    2. 其它原始类型，比较时先转换为数字，再进行比较
>    3. NaN与任何数字比较都是false，包括自身
>    4. Infinity 和 -Infinity 只能和自身相等
>    5. 对象比较时，要先转换为原始类型，再进行比较
>
> **由于相等比较和不相等比较，对于不同类型的数据比较违反直觉，因此，通常我们不使用这种比较方式，而是使用更加接近直觉的严格相等和严格不相等比较**
>
> `===`：两端的数据和类型必须相同
>
> `!==`：两端的数据或类型不相同
>
> 1. 两端类型相同，规则和比较相等一致
> 2. 两端的类型不同，为false
>
> 一个小细节：
>
> ```yaml
> 10 > 9 > 8 === true
> # false
> # 因为比较运算符的返回结果为boolean类型，10 > 9返回true，true再与8比较则为false，所以整个相等比较的结果为false
> ```



- 逻辑运算符

> 布尔运算符
>
> - 与（并且）
>   - 符号：`&&`
>   - 书写方式：`表达式1 && 表达式2`
>
> 1. 将表达式1进行boolean判定
> 2.  如果表达式1的判定结果为假，则直接返回表达式1，而不执行表达式2；否则，返回表达式2的结果。(短路规则)
>
> - 或
>   - 符号：`||`
>   - 写法：`表达式1 || 表达式2`
>
> 1. 将表达式1进行boolean判定
> 2. 如果表达式1为真，直接返回表达式1，不运行表达式2；否则，返回表达式2的结果。
>
> - 非
>   - 符号：`!`
>   - 写法：`!数据`
>
> 1. 一元运算符
>
> 2. 数据的boolean判定结果直接取反。非运算符一定返回boolean类型



- 三目运算符

> - 书写方式：`表达式1 ? 表达式2 : 表达式3`
>
> 1.  对表达式1进行boolean判定
> 2. 如果判定结果为真，返回表达式2；否则，返回表达式3



- 运算符补充

> 类型转换不会影响原本的数据
>
> 复合的赋值运算符：`+= -= /= *= %= **=`
>
> void运算符：
>
> - 一元运算符
> - 普通写法：`void 表达式`
> - 函数写法：`void(表达式)`
> - 运行表达式，然后返回undefined
>
> typeof运算符：
>
> - 一元运算符
> - 普通写法：`typeof 表达式`
> - 函数写法：`typeof(表达式)`
> - typeof运算符，返回表达式的类型，是一个字符串
>
> 逗号运算符：
>
> - 写法：`表达式1，表达式2`
> - 依次运行两个表达式，返回表达式2
> - 逗号运算符的优先级，比赋值更低
>
> 一个小细节：
>
> ```js
> var x = 1;
> x = x++ * 2, x++ * 2, x++ * 2;
> console.log(x); # 4
> # 上面代码的运行过程：(x = x++ * 2), x++ * 2, x++ * 2;
> # 由于逗号运算符的优先级比赋值更低，所以先赋值，再运行逗号运算符，最后一个表达式运行完，x的值为4
> 
> var x = 1;
> x = (x++ * 2, x++ * 2, x++ * 2);
> console.log(x); # 6
> # 逗号运算符是依次运行表达式，然后返回最后一个表达式的值，最后一个表达式的值为6，然后给x赋值，x的值为6
> ```



### 流程控制

- 流程图

> 在markdown中画图：https://mermaid-js.github.io/mermaid/#/



- if判断

> 1. 如果某个条件满足，则直接忽略后面的条件
> 2. `else if` 可以有多个（包括0个）
> 3. `else` 可以有1个或0个
> 4. `else` 可以换行，可以不换行
> 5. 如果代码块只有一条语句，可以省略花括号
> 6. `if` 只能出现一次
>
> 补充：
>
> 1. 用户输入：`prompt("提示文本")`
>    1. null：用户点击了取消
>    2. 用户输入的字符串：表示用户点击了确定，得到用户输入的结果
>
> - 返回类型：null 或 字符串
>
> 2. 将字符串转换成数字：`+字符串`
> 3. 得到一个随机数
>    1. `Math.random()` ：该表达式返回一个0~1之间的随机数（无法取到1）



- switch开关

> ```js
> switch(表达式){
>     case 数据1:
>         代码块
>     case 数据2:
>         代码块
>     default:
>         代码块
> }
> # 计算表达式的返回值，依次和case后面的数据进行严格相等的比较，如果某个相等，停止比较，然后运行其内部的代码块，再然后，依次运行之后的所有代码块
> # 在case分支内部，使用break语句，可以立刻停止switch结构
> # default表示前面的所有case都不匹配时运行，可以省略
> ```



- 循环

> ```js
> # while
> while(条件){
>     代码块
> }
> 
> # do-while
> do{
>     循环体
> }while(条件)
> 
> # for循环
> for(初始化表达式; 条件; 条件改变表达式){
>     循环体
> }
> 
> # 循环体控制语句
> - break：跳出循环
> - continue：停止当前循环体，跳入下一次循环
> ```



- 数组

> 用于存放多个数据的
>
> ```js
> # 创建一个数组
> 1. new Array(长度)
> 长度：数组中的数据总数，是一个非负整数
> new Array(数据，数据，数据...)
> 创建一个数组，并初始化每一项的值
> 
> 2. [数据，数据，数据...]
> 创建一个数组，并初始化每一项的值
> 
> # 数组的本质
> 数组的本质是一个对象
> - length属性：数组的长度，会自动变化，值为最大小标+1
> - 数字字符串属性：叫做下标，也叫做索引，下标从0开始
> 实际开发中不要给length赋值
> 
> # 下标
> 通常情况下，下标是连续的
> 下标不连续的数组，叫做稀松数组
> ```
>
> 数组的常见操作：
>
> - 数组[长度] = 数据：向数组末尾添加一个数据
> - 数组.push(数据)：向数组末尾添加一个数据
> - 数组.unshift(数据)：向数组起始位置添加一个数据，会导致数组的每一项下标向后移动
> - 数组.splice(下标，0，田间的数据)：删除0个，然后在该位置插入添加的数据，如果下标超过范围，则按照范围的边界进行处理
>
> push、unshift、splice可以添加多个数据
>
> 删除数据：
>
> -  delete 数组[下标]：这种做法不会导致数组其它的属性发生变化，因此，该做法会导致产生稀松数组，所以不推荐使用该做法
> - 数组.pop()：删除数组的最后一项，该表达式返回最后一项的数据
> - 数组.shift()：删除数据第一项，该表达式返回第一项的数据
> - 数组.splice(下标，删除的数量，添加的数据)：从指定下标位置开始，删除指定数量，然后在该位置插入添加的数据，如果下标超过范围，则按照范围的边界进行处理
>
> 其它操作：
>
> - 数组.slice(起始位置下标，结束位置下标)：将起始位置到结束位置之间的数据拿出来，得到一个新的数组，该函数不会改变原数组；注意：结束下标取不到
>   - 下标可以写负数，如果是负数，则从数组的末尾开始计算
>   - 如果不写结束下标，则直接取到末尾
>
> - 数组清空
>   - 数组.splice(0，数组.length)
>   - 数组.length = 0
> - 查找数组中某一项的下标
>   - 数组.indexOf(数据)
>   - 从数组中依次查找对应的数据，查找时使用严格相等进行比较，找到第一个匹配的下标返回,如果没有找到，则得到-1
>   - 数组.lastIndexOf(数据)
> - 数组.fill
>   - 数组.fill(数据)：将数组的所有项，填充为指定的数据
>   - 数组.fill(数据，开始下标)：将数组从指定的下标起，到数组的末尾，填充为指定的数据
>   - 数组.fill(数据，开始下标，结束下标)：将数组从指定的下标起，到数组的结束下标（取不到），填充为指定的数据
>
> 语法补充：
>
> - in关键字
>   - 判断某个属性在对象中是否存在(注意是属性)
>   - 属性名 in 对象
> - for-in循环
>
> ```js
> for(var prop in obj){
>     循环体
> }
> # 取出对象的所有属性名，每次循环将其中一个属性名赋值给变量prop，运行循环体
> # for-in循环，循环不到稀松数组中不存在的值，for循环能循环到，值为undefined
> ```
>



### 函数

- 函数语法

> 函数主要用于减少代码重复
>
> #### 创建（定义、声明）函数
>
> ```js
> function 函数名(){
>     // 函数体
> }
> # 函数体的代码不会直接运行，必须手动调用函数，才能运行其中的代码
> ```
>
> #### 调用函数
>
> ```js
> 函数名()
> ```
>
> #### 函数提升
>
> - 通过**字面量**声明的函数，会提升到脚本块的顶部
> - 通过**字面量**声明的函数，会成为全局对象的属性
>
> #### 其它特点
>
> - 通过`typeof` 函数名，得到的结果是`function`
>
> 函数内部声明的变量：
>
> 1. 如果不使用var声明，和全局变量一致，表示给全局对象添加属性
> 2. 如果使用var声明，变量提升到所在函数的顶部，函数外部不能使用该变量
>
> **函数中声明的变量，仅能在函数中使用，在外部无效**
>
> #### 参数
>
> 参数表示函数运行的未知条件，需要调用者告知的数据
>
> ```js
> // 参数的有效返回在函数体中
> function 函数名(形参1，形参2){
>     
> }
> 函数名(实参);
> # 如果没有传递实参，则对应的形参为undefined
> ```
>
> #### 返回值
>
> - 函数运行后，得到的结果。调用函数时，调用表达式的值就是函数的返回值
>
> - return会直接结束整个函数的运行
> - return后面不跟任何数据，返回undefined
> - 如果函数中没有书写return，则该函数会在末尾自动return undefined
>
> #### 经典面试题
>
> ```js
> var a;// 函数 a 的声明提前
> var a = 0;  // 已经声明了 a，这里会忽略声明 ,直接赋值为 0
> if (true) {
>     a = 1; // 这里将 块级作用域最前面的函数 a 重置为 1了。
>     function a() { };
>     a = 21;
> 	console.log("里面", a);
> }
> console.log("外部", a);
> ```
>
> ```js
> var a = 0;
> if (true) {
>     console.log(a, window.a);// 函数提升，是块级作用域，输出 function a 和 0
>     a = 1;  // 取作用域最近的块级作用域的 function a ,且被重置为 1了，本质又是一个 变量的赋值。
>     console.log(a, window.a);// a 是指向块级作用域的 a, 输出 1 和 0 
>     function a() { } // 函数的声明，将执行函数的变量的定义同步到函数级的作用域。
>     console.log(a, window.a);// 输出 1 和 1
>     a = 21; // 仍然是函数定义块级作用域的 a ,重置为 21
>     console.log(a, window.a); // 输出为函数提升的块级作用域的 a, 输出 21，1
>     console.log("里面", a);
> }
> console.log("外部", a);
> ```
>



- 作用域和闭包

> 作用域表示一个代码区域，也表示一个运行环境
>
> JS中，有两种作用域：
>
> 1. 全局作用域
>    1. 直接在脚本中书写的代码
>    2. 在全局作用域中声明的变量，会被提升到脚本块的顶部，并且会成为全局对象的属性
> 2. 函数作用域
>    1. 函数中的代码
>    2. 在函数作用域中声明的变量，会被提升到函数的顶部，并且不会成为全局对象的属性
>
> **函数中声明的变量不会导致全局对象的污染**
>
> **尽量的把功能封装在函数中**
>
> 当函数成为一个表达式时，它既不会提升，也不会污染全局对象
>
> #### 作用域中可以使用的变量
>
> 全局作用域只能使用全局作用域中声明的变量（包括函数）
>
> 函数作用域中不仅能使用自身作用域中声明的变量（包括函数），还能使用外部环境的变量（包括函数）
>
> 函数内部声明的变量和外部冲突时，使用内部的
>
> #### 闭包
>
> 闭包：是一种现象，内部函数，可以使用外部函数环境中的变量



- 函数表达式和this

> #### 函数表达式
>
> JS中，函数也是一种数据，语法上，函数可以用于任何需要函数的地方
>
> 函数是一个引用类型，将其赋值给某个变量时，变量中保存的是函数的地址
>
> #### this关键字
>
> 1. 在全局作用域中，this关键字固定指向全局对象
> 2. 在函数作用域中，取决于函数是如何被调用的
>    1. 函数直接调用，this指向全局对象
>    2. 通过一个对象的属性调用，格式为 `对象.属性` 或 `对象["属性"]` ，this指向对象



- 构造函数

> 对象中的属性，如果是一个函数，也称该属性为对象的方法
>
> #### 用于创建对象的函数
>
> 1. 函数返回一个对象
> 2. 构造函数，构造函数专门用于创建对象
>
> ```js
> new 函数名(参数);
> # 使用这种格式创建的对象，则该函数叫做构造函数
> ```
>
> - 函数名使用大驼峰命名法
> - 构造函数内部，会自动创建一个新对象，this指向新创建的对象，并且自动返回新对象
> - 构造函数中如果出现返回值，如果返回的是原始类型，则直接忽略；如果返回的是引用类型，则使用返回的结果
> - 所有的对象，最终都是通过构造函数创建的
>
> #### new.target
>
> 该表达式在函数中使用，返回的是当前的构造函数，但是，如果该函数不是通过new调用的，则返回undefined
>
> 通常用于判断某个函数是否通过new在调用



- 函数的本质

> 函数的本质就是对象
>
> - 所有的对象都是通过关键字new出来的`new 构造函数()`
>
> 所有的函数都是通过`new Function` 创建
>
> ```js
> new Function -> 创建函数(Object、Array、User...) -> new Object()创建对象(普通对象)或new User()创建对象
> ```
>
> ```js
> function sum(a, b){
>     return a + b;
> }
> 
> var sum = new Function("a", "b", "return a + b");
> console.log(typeof sum); // function
> console.log(sum(2, 3));
> ```
>
> > Function
> >
> > 由于函数本身就是对象，因此函数中，可以拥有各种属性
>
> #### 包装类
>
> JS为了增强原始类型的功能，为boolean、string、number分别创建了一个构造函数
>
> 1. Number
> 2. String
> 3. Boolean
>
> 如果语法上，将原始类型当作对象使用时（一般是在使用属性时），JS会自动在该位置利用对应的构造函数，创建对象来访问原始类型的属性
>
> > 类：在JS中，可以认为类就是构造函数
>
> > 成员属性 (方法)，实例属性 (方法)：表示该属性是通过构造函数创建的对象调用的
> >
> > ```js
> > var num = new Number(3.1415926);
> > num.toFixed();
> > ```
> >
> > 静态属性 (方法)、类属性 (方法)：表示该属性是通过构造函数本身调用的。



- 递归

> 函数直接或间接调用自身
>
> 避免无限递归，无限递归会导致执行栈溢出
>
> 对比死循环：
>
> 1. 死循环不会报错，也不会导致栈溢出
> 2. 无限递归会导致栈溢出
>
> #### 执行栈
>
> 任何代码的执行都必须有一个执行环境，执行环境为代码的执行提供支持
>
> 执行环境是放到执行栈中的
>
> 每个函数的调用，都需要创建一个函数的执行环境，函数调用结束，执行环境销毁
>
> 执行栈有固定的大小，如果执行环境太多，执行栈无法容纳，会报错
>
> #### 尾递归
>
> 如果一个函数最后一条语句是调用函数，并且调用函数不是表达式的一部分，则该语句称之为尾调用，如果调用是调用自身函数，则称为尾递归。
>
> 某些语言或执行环境会对尾调用进行优化，它们会理解销毁当前函数，避免执行栈空间被占用。
>
> 在浏览器执行环境中，尾调用没有优化。但在node.js环境中有优化。



### 标准库

- Object和Function

> #### Object
>
> ##### 静态成员
>
> - keys(某个对象)：得到某个对象的所有属性名数组
> - values(某个对象)：得到某个对象的所有属性值数组
> - entries(某个对象)：得到某个对象的所有属性名和属性值的数组，是一个二维数组
>
> ##### 实例成员
>
> > 实例成员可以被重写
> >
> > **所有对象，都拥有Object的所有实例成员**
>
> - toString方法：得到某个对象的字符串格式
>
> 默认情况下，该方法返回`"[object Object]"`
>
> - valueOf方法：得到某个对象的值
>
> 默认情况下，返回该对象本身
>
> 在JS中，当自动的进行类型转换时，如果要对一个对象进行转换，实际上是先调用对象的valueOf方法，然后调用返回结果的toString方法，将得到的结果进行进一步转换
>
> #### Function
>
> **所有函数都具有Function中的实例成员**
>
> **语法：arguments在函数中使用，获取该函数调用时，传递的所有参数**
>
> **arguments是一个类数组（也称为伪数组：没有通过Array构造函数创建的类似于数组结构的对象），伪数组会缺少大量的数组实例方法**
>
> **arguments数组中的值，会与对应的形参映射**
>
> **传入的参数没有时不映射，为undefined时映射，在函数里面改动参数，arguments映射的会改动，没有映射的则不在arguments中映射**
>
> #### 实例成员
>
> - length属性：得到函数形参数量
> - apply方法：调用函数，同时指定函数中的this指向，参数以数组传递
> - call方法：调用函数，同时指定函数中的this指向，参数以列表传递
> - bind方法：得到一个新的函数，该函数中的this始终指向指定的值。
>
> 通常，可以利用apply、call方法，将某个伪数组转换为真数组。



- Array构造器

> 凡是通过Array构造函数创建的对象，都是数组
>
> #### 静态成员
>
> - from方法：可以将一个伪数组转换为真数组
> - isArray方法：判断一个给定的数据，是否是一个真数组
> - of方法：类似于中括号创建数组，依次赋予数组每一项的值
>
> #### 实例成员
>
> - fill方法：用某个数组填充数组
> - pop
> - push
> - reverse：将当前数组颠倒顺序 
> - shift
> - sort：对数组进行排序
> - splice
> - unshift
>
> 纯函数，无副作用函数，不会导致当前对象发生改变
>
> - concat
> - includes：数组中是否包含满足条件的元素
> - join
> - slice
> - indexOf
> - lastIndexOf
> - forEach：遍历数组
> - every：是否所有元素都满足条件
> - some：是否至少有一个元素满足条件
> - filter：过滤，得到满足条件的元素组成的新数组
> - find：查找第一个满足条件的元素，返回元素本身，如果没有找到，返回undefined
> - findeIndex：查找第一个满足条件的元素，返回元素的下标
> - map：映射，将数组的每一项，映射成为另一项
> - reduce：统计，累计，第二个参数是初始值

###  原型和原型链

- 所有对象都是通过```new 函数``` 创建
- 所有的函数也是对象
  - 函数中可以有属性
- 所有的对象都是引用类型

#### 原型 ```prototype```

所有函数都有一个属性：```prototype```，称之为函数原型

默认情况下，`prototype`是一个普通的`object`对象

默认情况下，`prototype`中有一个属性`constructor`，它也是一个对象，它指向构造函数本身

#### 隐式原型 `__proto__`

所有的对象都有一个属性：`__proto__`，称之为隐式原型

默认情况下，隐式原型指向创建该对象的函数的原型

当访问一个对象的成员时：

1. 看该对象自身是否拥有该成员，如果有直接使用
2. 在原型链中依次查找是否拥有该成员，如果有直接使用

猴子补丁：在函数原型中加入成员，以增强其对象的功能，猴子补丁会导致原型污染，使用须谨慎

#### 原型链

特殊点：

1. `Function`的`__proto__` 指向自身的`prototype`
2. `Object`的`prototype`的`__proto__` 指向`null`



函数是通过`new Function` 创建的：

<img src="D:\15项目\笔记\三件套\js\img\函数是通过new Function创建的.jpg" style="zoom:50%;" />

每个函数都有原型对象：
<img src="D:\15项目\笔记\三件套\js\img\每个函数都有原型对象.jpg" style="zoom:50%;" />

普通对象是通过`new Function` 创建的：

<img src="D:\15项目\笔记\三件套\js\img\普通对象是通过new 函数创建的.jpg" style="zoom:50%;" />

隐式原型的指向：

<img src="D:\15项目\笔记\三件套\js\img\隐式原型的指向.jpg" style="zoom:50%;" />

原型中的`constructor` 指向函数本身：

<img src="D:\15项目\笔记\三件套\js\img\原型中的constructor指向函数本身.jpg" style="zoom:50%;" />

链条的全貌：

<img src="D:\15项目\笔记\三件套\js\img\链条的全貌.jpg" style="zoom:50%;" />

三道面试题：

```js
var F = function (){}
Object.prototype.a = function (){}
Function.prototype.b = function (){}
var f = new F();
console.log(f.a, f.b, F.a, F.b);
```

```js
function A(){}
function B(a){
    this.a = a;
}
function C(a){
    if(a){
        this.a = a;
    }
}
A.prototype.a = 1;
B.prototype.a = 1;
C.prototype.a = 1;

console.log(new A().a);
console.log(new B().a);
console.log(new C(2).a);
```

```js
function User(){}
User.prototype.sayHello = function (){}

var u1 = new User();
var u2 = new User();

console.log(u1.sayHello === u2.sayHello);
console.log(User.prototype.constructor);
console.log(User.prototype === Function.prototype);
console.log(User.__proto__ === Function.prototype);
console.log(User.__proto__ === Function.__proto__);
console.log(u1.__proto__ === u2.__proto__);
console.log(u1.__proto__ === User.__proto__);
console.log(Function.__proto__ === Object.__proto__);
console.log(Function.prototype.__proto__ === Object.prototype.__proto__);
console.log(Function.prototype.__proto__ === Object.prototype);
```



### 原型链的应用

#### 基础方法

W3C不推荐直接使用系统成员`__proto__`

> **1. Object.getPrototypeOf(对象)**
>
> 获取对象的隐式原型
>
> **2. Object.prototype.isPrototypeOf(对象)**
>
> 判断当前对象（this）是否在指定对象的原型链上
>
> **3. 对象 `instanceof` 函数**
>
> 判断函数的原型是否在对象的原型链上
>
> **4. Object.create(对象)**
>
> 创建一个新对象，其隐式原型指向指定的对象
>
> **5. Object.prototype.hasOwnProperty(属性名)**
>
> 判断一个对象**自身**是否拥有某个属性

#### 应用

> **类数组转换为真数组**
>
> `Array.prototype.slice.call(类数组)`
>
> **实现继承**
>
> 默认情况下，所有构造函数的父类都是Object
>
> 圣杯模式

### 属性描述符

属性描述符：它表达了一个属性的相关信息（元数据），它本质上是一个对象

1. 数据属性
2. 存取器属性：
   1. 当给它赋值，会自动运行一个函数
   2. 当获取它的值时，会自动运行一个函数

**Object.getOwnPropertyDescriptor**

获取某个对象的某个属性的属性描述符对象（该属性必须直接属于该对象）

### 执行上下文

函数执行上下文：一个函数运行之前，创建的一块内存空间，空间中包含有该属性执行所需要的数据，为该函数执行提供支持

执行上下文栈：callback，所有执行上下文组成的内存空间

栈：一种数据结构，先进后出，后进先出

全局执行上下文：所有JS代码执行之前，都必须有该环境

JS引擎始终执行的是栈顶的上下文.

#### 执行上下文中的内容

> 1. this指向
>
> - 直接调用函数，this指向全局对象
> - 在函数外，this指向全局对象
> - 通过对象调用或new一个函数，this指向调用的对象或新对象
>
> 2. VO变量对象
>
> - Variable Object：VO中记录了该函数中所有声明的参数、变量和函数
> - Global Object：GO，全局执行上下文中的VO
> - Active Object：AO，当前正在执行的上下文中的VO
>
> > 确定所有形参值以及特殊变量arguments
> >
> > 确定函数中通过var声明的变量，将它们的值设置为undefined，如果VO中已有该名称则直接忽略
> >
> > 确定函数中通过字面量声明的函数，将它们的值设置为指向函数对象，如果VO中已存在该名称，则覆盖
>
> 当一个上下文中的代码执行的时候，如果上下文中不存在某个属性，则会从之前的上下文寻找

4道面试题：

```js
var foo = 1;
function bar(){
	console.log(foo);
    if(!foo){
        var foo = 10;
    }
    console.log(foo);
}
bar();
```

```js
var a = 1;
function b(){
    console.log(a);
    a = 10;
    return;
    function a(){}
}
b();
console.log(a);
```

```js
console.log(foo);
var foo = "A";
console.log(foo);
var foo = function (){
    console.log("B");
}
console.log(foo);
foo();
function foo(){
    console.log("C");
}
console.log(foo);
foo();
```

```js
var foo = 1;
function bar(a){
    var a1 = a;
    var a = foo;
    function a(){
        console.log(a);
    }
    a1();
}
bar(3);
```



### 作用域链

1. VO中包含一个额外的属性，该属性指向创建该VO的函数本身
2. 每个函数在创建时，会有一个隐藏属性```[[scope]]``` ，它指向创建该函数时的AO
3. 当访问一个变量时，会先查找自身VO中是否存在，如果不存在，则依次查找```[[scope]]``` 属性

某些浏览器会优化作用域链，函数的```[[scope]]``` 中仅保留需要用到的数据

4道面试题：

```js
var foo = {n: 1};
(function (foo){
    console.log(foo.n);
    foo.n = 3;
    var foo = {n: 2};
    console.log(foo.n);
})(foo);
console.log(foo.n);
```

```js
var food = "rice";
var eat = function () {
    console.log(`eat ${food}`);
};
(function () {
    var food = "noodle";
    eat();
})();
```

```js
var food = "rice";
(function(){
    var food = "noodle";
    var eat = function(){
        console.log(`eat ${food}`);
    };
    eat();
})();
```

```js
function A() {
    for (i = 0; i < 10; i++) {
        setTimeout(function () {
            console.log(i);
        }, 1000)
    }
}

A();

console.log(i);


for (var i = 0; i < 3; i++) {
    (function (i) {
        setTimeout(function () {
            console.log(i);
        }, 1000)
    }(i));
}
```



### 事件循环

> 异步：某些函数不会立即执行，需要等到某个时机成熟后才会执行，该函数叫做异步函数
>
> 浏览器的线程：
>
> 1. JS执行引擎：负责执行JS代码
> 2. 渲染引擎：负责渲染页面
> 3. 计时器线程：负责计时
> 4. 事件监听线程：负责监听事件
> 5. HTTP网络线程：负责网络通信
>
> 事件队列：一块内存空间，用于存放执行时机到达的异步函数。当JS引擎空闲（执行栈没有可执行的上下文），它会从事件队列中拿出第一个函数执行
>
> 事件循环：event  loop，是指函数在执行栈、宿主线程、事件队列中的循环移动

