# css

## 基础

1. css sprite（精灵）是什么，有什么优缺点
2. display：none与visibility：hidden的区别
3. link与@import的区别
4. 什么是FOUC，如何避免
5. 如何创建块级格式化上下文（BFC），有什么用
6. display、float、position的关系
7. 清楚浮动的几种方式，各自的优缺点
8. 为什么要初始化css样式
9. css3有哪些新特性
10. display有哪些值，说明它们的作用
11. 介绍一下标准的css的盒子模型，与低版本IE的盒子模型有什么不同
12. css优先级如何计算
13. 对BFC规范的理解
14. 谈谈浮动和清除浮动
15. position的值，relative和absolute的定位原点是什么
16. display：inline-block什么时候不会显示间隙
17. 行内元素float：left后是否变为块级元素
18. ::before和:after中双冒号和单冒号有什么区别，解释一下这两个伪元素的作用
19. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？
20. css不同选择器的权重
21. css在性能优化方面的实践
22. base64的原理及优缺点
23. 几种常见的css布局
24. stylus、sass、less的区别
25. postcss的作用
26. css样式（选择器）的优先级
27. 伪类和伪元素的区别
28. base64的作用
29. 自适应布局
30. 什么是外边距重叠，重叠的结果是什么
31. rgba和opacity的透明效果有什么不同
32. css中可以让文字在垂直和水平方向上重叠的两个属性是什么
33. 如何垂直居中一个浮动元素
34. px和em的区别
35. sass和less是什么，为什么使用它们
36. css的content属性有什么作用，有什么应用
37. 水平居中的方法
38. 垂直居中的方法
39. 重绘和回流是什么，如何避免
40. 说一说css3的animation
41. 左边宽度固定，右边自适应
42. 两种方法以上实现已知或者未知宽度的垂直水平居中
43. 如何实现小于12px的字体效果
44. css hack原理及常用hack
45. css有哪些继承属性
46. 外边距折叠
47. css选择符有哪些，哪些属性可以继承
48. css3新增伪类有哪些
49. 如何居中div，如何居中一个浮动元素，如何让绝对定位的div居中
50. 用纯css绘制一个三角形的原理是什么
51. 一个满屏品字布局如何设计
52. css3的弹性盒布局以及使用场景
53. 等高布局
54. 浮动元素引起的问题
55. css优化，提高性能的方式有哪些
56. 浏览器是怎样解析css选择器的
57. 全屏滚动的原理是什么，用到了css的哪些属性
58. 什么是响应式设计，响应式设计的基本原理是什么，如何兼容低版本的IE
59. a标签上4个伪类的执行顺序是怎样的
60. line-height的赋值方式和理解



## 进阶

1. 盒模型
2. BFC
3. 层叠上下文
4. 左右居中方案
5. 上下垂直居中方案
6. 选择器权重计算方式
7. 清除浮动
8. 左边定宽，右边自适应布局
9. 左右两边定宽，中间自适应
10. css动画和过渡
11. css3的新特性
12. 列举几个css中可继承和不可继承的元素



## css

css规则 = 选择器 + 声明块

css代码书写位置：

1. 内部样式表（行内样式）：书写在style中
2. 内联样式表：直接书写在元素的style属性中
3. 外部样式表：将样式书写到独立的css文件中
   1. 可以解决多页面样式重复的问题
   2. 有利于浏览器缓存，提高页面响应速度
   3. 有利于代码分离，更容易维护和阅读



- 常见样式声明

> 暂无



- 选择器

> 1. ID选择器
> 2. 元素选择器（标签选择器）
> 3. 类选择器
> 4. 通配符选择器
> 5. 属性选择器
> 6. 伪类选择器
> 7. 伪元素选择器
>
> 选择器的组合：
>
> 1. 并且（```p.red```）
> 2. 后代元素（```div span```）
> 3. 子元素（```div > ul```）直接子元素，ul下面的li就不能选中了
> 4. 相邻兄弟元素（```div + div```）相邻兄弟元素
> 5. 兄弟元素（```div ~ div```）后面出现的所有兄弟元素
>
> 选择器的并列：
>
> 多个选择器，用逗号分隔



- 层叠

> 声明冲突：同一个样式，多次应用到同一个元素（```background:red``` ```background:pink```）
>
> 层叠：解决声明冲突的过程，浏览器自动处理（权重计算）
>
> 1. 比较重要性（重要性从高到低）
>    1. 作者样式表中的```!important``` 样式
>    2. 作者样式表中的普通样式
>    3. 浏览器默认样式表中的样式
> 2. 比较特殊性（选择器选中的范围越窄越特殊），具体规则：通过选择器计算出一个四位数
>    1. ```!important```	```infinity```
>    2. 行间样式          ```1000```
>    3. ID选择器          ```100```
>    4. class选择器 | 属性选择器 | 伪类选择器    ```10```
>    5. 元素选择器（标签）| 伪元素选择器         ```1```
>    6. 通配符选择器                                     ```0```
> 3. 比较源次序
>    1. 代码书写靠后的胜出
>
> 冯256进1
>
> 应用：
>
> 1. 重置样式表：书写一些作者样式，覆盖浏览器的默认样式
> 2. 爱恨法则（```LoVe``` ```HAte```）
>    1. link > visited > hover > active



- 继承

> 子元素会继承父元素的某些css属性
>
> 通常跟文字相关的属性都能被继承
>
> 可以被继承的元素：
>
> 暂无



- 属性值的计算过程

> 渲染每个元素的前提条件：该元素的所有css属性必须有值
>
> 属性值计算过程简介：
>
> <img src="D:\15项目\笔记\三件套\css\img\image-20220106112449727.png" alt="image-20220106112449727" style="zoom: 50%;" />
>
> <img src="D:\15项目\笔记\三件套\css\img\Snipaste_2022-01-06_11-27-51.png" style="zoom:50%;" />
>
> 1. 确定声明值：参考作者样式表和浏览器默认样式表中没有冲突的声明，作为css属性值
> 2. 层叠冲突：对样式表中有冲突的声明使用层叠规则，确定css属性值（比较重要性、比较特殊性、比较源次序）
> 3. 使用继承：对仍然没有值的属性，**若可以继承**（有些css属性不能继承），则继承父元素的值
> 4. 使用默认值：对仍然没有值的属性，使用默认值



- 盒模型

> 盒子类型：
>
> 1. 行盒：display等于inline的元素（行盒在页面中不换行）
> 2. 块盒：display等于block的元素（块盒独占一行）
>
> display默认值为inline，容器元素在浏览器中的默认样式为块盒
>
> 常见的行盒：span、audio、video、a、img、i、strong、em
>
> 盒子的组成部分：（行盒和块盒都是由下面几部分组成，从内到外）
>
> 1. content（内容）**内容盒 content-box**
>    1. width、height 设置的是盒子内容的宽高
> 2. padding 填充（内边距）**填充盒 padding-box** ```填充区 + 内容区```
>    1. 盒子边框到盒子内容的距离（速写属性：```padding：top right bottom left``` ）
> 3. border（边框）**边框盒 border-box** ```边框 + 填充区 + 内容区```
>    1. 边框 = 边框样式（border-style） + 边框宽度（border-width） + 边框颜色（border-color）
> 4. margin（外边距）
>    1. 边框到其它盒子的距离（速写属性：```margin：top right bottom left```）
>
> 盒模型的应用：
>
> 1. 默认情况下，width和height设置的是**内容盒**的宽高，量尺寸时则量的是**边框盒**，可以通过下面两种方式解决
>    1. 精确计算（内容盒和边框盒）
>    2. ```css3：box-sizing```
> 2. 默认情况下，背景覆盖**边框盒**
>    1. 通过```background-clip```进行修改
> 3. overflow：控制内容溢出边框盒后的处理方式
> 4. word-break：会影响文字在什么位置被截断（断词规则）
>    1. normal：文字位置截断，单词位置截断（一行在单词盛不下时在单词之间截断，文字盛不下时截断）
>    2. break-all：截断所有，所有字符都在文字处截断（单词盛不下时会把单词的字母截断到下一行，文字盛不下时截断）
>    3. keep-all：保持所有，所有文字都在单词之间截断，中文会在空格之间截断（一行在单词盛不下时在单词之间截断，中文会在空格之间截断，如果一行可以盛下两句就不截断，一行盛不下一句也不截断）
> 5. 溢出打点：（空白处理）
>    1. ```white-space：nowrap```
>    2. ```overflow：hidden```
>    3. ```text-overflow：ellipsis```



- 行盒的盒模型

> 特点：
>
> 1. 盒子沿着内容延申
> 2. 行盒不能设置宽高（行盒的宽高应该使用字体大小、行高、字体类型间接调整）
> 3. 内边距（填充区）：水平方向有效，垂直方向不会实际占据空间
> 4. 边框：水平方向有效，垂直方向不会实际占据空间
> 5. 外边距：水平方向有效，垂直方向不会实际占据空间
>
> 行块盒：
>
> 1. 不独占一行
> 2. 盒模型中所有尺寸都有效
>
> 空白折叠：发生在行盒（行块盒）内部或行盒（行块盒）之间
>
> 可替换元素和非可替换元素：页面上显示的结果，取决于元素内容，称为**非可替换元素**，页面上显示的结果，取决于元素属性，称为**可替换元素**
>
> 可替换元素：img、video、audio
>
> 绝大多数可替换元素均为行盒，可替换元素类似于行块盒，盒模型中所有尺寸都有效



- 常规流

> 盒模型：规定单个盒子的规则
>
> 视觉格式化模型（布局规则）：页面中多个盒子的布局规则，大体上将页面中盒子的排列分为三种方式
>
> 1. 常规流
> 2. 浮动
> 3. 定位
>
> 常规流布局：（默认情况下，所有元素，都属于常规流布局）
>
> 1. 总体规则：块盒独占一行，行盒水平依次排列
> 2. 包含块（cataining block）：每个盒子都有它的包含块，包含块决定了盒子的活动区域
> 3. 绝大多数情况下，盒子的**包含块为其父元素的内容盒**
>
> 块盒：
>
> 1. 每个块盒的总宽度（所占的区域），必须刚好等于包含块的宽度
>    1. 宽度的默认值是auto（auto将剩余空间吸收掉）
>    2. margin也可以取值为auto，默认值0
>    3. width吸收能力强于margin
>    4. 宽度、边框、内边距、外边距计算后，仍有剩余空间，剩余空间被margin-right全部吸收
> 2. 每个块盒垂直方向上的auto值
>    1. height：auto，适应内容的高度
>    2. margin：auto，表示0
> 3. 百分比取值
>    1. padding、width、margin可以取值为百分比（这三个的百分比是相对于包含块的宽度，跟高度没有关系）
>    2. 高度的百分比：
>       1. 包含块的高度是否取决于子元素的高度，设置百分比无效
>       2. 包含块的高度不取决于子元素的高度，百分比相对于父元素高度
> 4. 上下外边距合并
>    1. 两个常规流块盒，上下外边距相邻，会进行合并
>    2. 两个外边距取最大值
>    3. 父子元素相邻也要合并



- 浮动

> 应用场景：
>
> 1. 文字环绕
> 2. 横向排列
>
> 特点：
>
> 1. 当一个元素浮动后，元素必定为块盒（更改display属性为block）
> 2. 浮动元素的包含块，和常规流一样，为父元素的内容盒
>
> 盒子尺寸：
>
> 1. 宽度为auto时，适应内容宽度
> 2. 高度为auto时，适应内容的高度
> 3. margin为auto时，为0（在浮动下面）
> 4. 边框、内边距、百分比设置与常规流一样
>
> 盒子排列：
>
> 1. 左浮动的盒子，靠上靠左排列
> 2. 右浮动的盒子，靠上靠右排列
> 3. 浮动盒子在包含块中排列时，会避开常规流块盒
> 4. 常规流块盒在排列时，无视浮动盒子
> 5. 行盒在排列时，会避开浮动盒子
> 6. 外边距合并不会发生
>
> - 如果文字没有在行盒中，浏览器会自动生成一个行盒包裹文字，该行盒叫做匿名行盒
> - 常规流块盒在排列时，无视浮动盒子，所以要在两者之间加间距的话，要给img元素的margin-right加
> - **文字环绕：文字之所以会避开图片，是因为文字内部有个匿名行盒，行盒在排列时，会避开浮动盒子。**
>
> 高度坍塌：
>
> 1. 原因：常规流盒子的自动高度，在计算时不会考虑浮动盒子
> 2. 清除浮动：```clear：left | right | both```



- 定位

> 手动控制元素在**包含块**中的精准位置
>
> position属性：
>
> 1. 默认值：static，静态定位（不定位）
> 2. relative：相对定位
> 3. absolute：绝对定位
> 4. fixed：固定定位
>
> - 只要一个元素的```position```属性值不为```static``` ，则认为该元素是一个定位元素
> - 定位元素会脱离文档流（相对定位除外）
>
> 相对定位：
>
> - 不会导致元素**脱离文档流**，只会让元素在原来位置上进行偏移
> - 盒子的偏移不会对其它盒子造成任何影响
>
> 绝对定位：
>
> 1. 宽高为auto，适应内容
> 2. 包含块变化，找祖先元素中第一个定位元素，该元素的**填充盒**为其包含块，若找不到，则它的包含块为整个网页
>
> 固定定位：
>
> - 其它情况和绝对定位完全一样
> - 包含块不同：固定为视口（浏览器的可视窗口）
>
> 定位下的居中：
>
> 1. 定宽（高）
> 2. 将左右（上下）距离设置为0
> 3. 将左右（上下）margin设置为auto
>
> - 绝对定位和固定定位中，margin为auto时，会自动吸收剩余空间
>
> 多个定位元素重叠时：
>
> - 设置```z-index``` 通常情况下，数值越大，越靠近用户
> - 只有定位元素设置```z-index``` 有效
> - ```z-index``` 可以是负数，如果是负数，则遇到常规流、浮动元素，会被其覆盖
>
> 补充：
>
> - 绝对定位、固定定位元素一定是块盒
> - 绝对定位、固定定位元素一定不是浮动
> - 没有外边距合并



- 更多的伪类选择器

> 暂无



- @规则

> 1. ```@import``` 路径：导入另外一个css文件
> 2. ```@charset``` "utf-8"：告诉浏览器，该css文件使用utf-8编码，必须写到css文件第一行
>
> - 其它的还有一些：```@media``` ```@keyframes``` ```@font-face``` 等



- web字体和图标

> - web字体
>   - 解决用户电脑上没有安装相应字体，当用户电脑上没有时，强制让用户安装
>   - 使用```@font-face``` 指令制作一个新字体
>
> ```css
> @font-face {
> 	font-family: "good night";
>     src: url("./font/晚安体.ttf");
> }
> p{
>     font-family: "good night";
> }
> ```
>
> - 字体图标
>   - iconfont.cn（阿里巴巴字体图标库）



- 块级格式化上下文

> 全称Block Formatting Context，简称：BFC
>
> 它是一块**独立的渲染区域**，它规定了在该区域中，**常规流块盒**的布局
>
> 常规流块盒的渲染规则：
>
> - 常规流块盒在水平方向上必须撑满包含块
> - 常规流块盒在包含块的垂直方向上依次摆放
> - 常规流块盒若外边距无缝相邻，则进行外边距合并
> - 常规流块盒的自动高度和摆放位置，无视浮动元素
>
> BFC渲染区域：
>
> 这个区域由某个HTML元素创建，以下元素会在其内部创建BFC区域
>
> - **根元素**：意味着，```<html>``` 元素创建的BFC区域，覆盖了网页中所有的元素
> - **浮动和绝对定位元素**
> - **```overflow```不等于```visible```的块盒**
>
> 具体规则：
>
> - 创建BFC的元素，它的自动高度需要计算浮动元素
> - 创建BFC的元素，它的边框盒不会与浮动元素重叠
> - 创建BFC的元素，不会和它的子元素进行外边距合并



- 布局

> 三栏布局：
>
> <img src="D:\15项目\笔记\三件套\css\img\Snipaste_2022-01-08_19-43-39.png" style="zoom:50%;" />
>
> 两栏布局：
>
> <img src="D:\15项目\笔记\三件套\css\img\Snipaste_2022-01-08_19-58-50.png" style="zoom:50%;" />
>
> 主区域代码靠前书写：
>
> <img src="D:\15项目\笔记\三件套\css\img\Snipaste_2022-01-08_20-15-49.png" style="zoom:50%;" />
>
> 等高布局：
>
> 后台页面的布局：
>
> 



- 浮动的细节规则

> 暂无



- 行高的取值

> ```line-height``` ：
>
> 1. px，像素值
>
> 2. 无单位的数字
>
> 3. em单位
>
>    1. 先把em单位转换为像素值，再继承（line-height是可继承属性）
>
>    2. ```css
>       .container{
>       	line-height: 2em; // 计算出的p元素的最终line-height为32px	
>           line-height: 2; // 纯数字时为其字体大小，先继承，再计算。计算出p1的line-height为80px，p2的line-height为24px
>       }
>       .p1{
>       	font-size: 40px;
>       }
>       .p2{
>           font-size: 12px;
>       }
>       <div class="container">
>       	<p class="p1">lorem</p>
>       	<p class="p2">lorem</p>
>       </div>
>       ```
>
>    3. 
>
> 4. 百分比



- body背景

> 暂无



- 行盒的垂直对齐

> 多个行盒垂直方向上的对齐：
>
> - 给没有对齐的元素设置```vertical-align``` 
>   - 预设值（top、bottom、middle）
>   - 数值
>
> 图片的底部白边：
>
> - 图片的父元素是一个块盒，块盒的高度自动，图片底部和父元素底边之间往往会出现白边
>   - 设置父元素的字体为0
>   - 将图片设置为块盒



- 参考线-深入理解字体

> 暂无



- 堆叠上下文

> 堆叠上下文（stack context）：它是一块区域，这块区域由某个元素创建，它规定了该区域中的内容在Z轴上排列的先后顺序
>
> 



- SVG

> 暂无



- 数据链接

> 暂无



- 浏览器兼容性

> 暂无



- 居中总结

> 居中：盒子在其包含块中居中
>
> - 行盒（行块盒）水平居中：
>   - 直接设置行盒（行块盒）父元素```text-align：center```
>
> - 常规流块盒水平居中：
>   - 定宽，设置左右```margin```为```auto```
> - 绝对定位元素的水平居中：
>   - 定宽，设置左右的坐标为0（```left：0，right：0```），将左右```margin```设置为```auto```
>   - 实际上，固定定位（fixed）是绝对定位（absolute）的特殊情况
> - 单行文本的垂直居中：
>   - 设置文本所在区域的行高，为整个区域的高度
> - 行块盒或块盒内多行文本的垂直居中：
>   - 没有完美方案，设置盒子上下内边距相同，达到类似的效果



- 样式补充

> 



object-fit

white-space

transform：translate不会改变盒子原本的排列方式